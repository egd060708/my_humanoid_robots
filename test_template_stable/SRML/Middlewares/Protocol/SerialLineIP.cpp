/**
 * @file SerialLineIP.hpp
 * @author BigeYoung (SCUT.BigeYoung@gmail.com)
 * @brief SerialLineIP 是一种简单的数据链路层串口协议，
 *  提供了封装成帧和透明传输的功能。
 * @warning STANDARD C++03 REQUIRED! 需要C++03以上标准支持！
 *  - C++03起，vector 元素相继存储，因此，您能用指向元素的常规指针
 *  访问元素。例如，对于返回值data，您可以使用&data[0]获取数组首地址。
 *  [C++标准:vector](https://zh.cppreference.com/w/cpp/container/vector)
 *  - 依照 ISO C++ 标准建议，本程序的函数直接返回 vector 容器。
 *  在支持具名返回值优化(NRVO)的编译器上可获得最佳性能。
 *  [C++标准:复制消除](https://zh.cppreference.com/w/cpp/language/copy_elision)
 * @see [RFC-1055: SLIP 协议文档](https://tools.ietf.org/html/rfc1055)
 * @version 0.1
 * @date 2018-12-24
 * 
 * @copyright Copyright 华工机器人实验室(c) 2018
 * 
 */
#include "srml_config.h"

#if USE_SRML_SERIAL_LINE_IP || USE_SRML_ASUWAVE_MONITOR

#include "SerialLineIP.hpp"
using namespace SerialLineIP;
using namespace std;

static uint16_t buffLen = 128;
__SRAM uint8_t* buff = (uint8_t*)malloc(buffLen);
/**
 * @brief Serial Line IP PACK
 * @param p_PDU 起始位置指针
 * @param PDU_len PDU 字节长度
 * @return 
 * @note Service Data Unit (SDU) 指本层封包后产生的数据单元
 *       Protocol Data Unit (PDU) 指上层协议数据单元
 */
pair<uint8_t*,int> SerialLineIP::Pack(const void *const p_PDU, int PDU_len)
{
    uint8_t *p_PDU_data = (uint8_t *)p_PDU;
    /* 计算所需内存空间
     */
    int SDU_len = PDU_len + 2; //添加首尾2个END
    for (uint8_t *p = p_PDU_data; p < p_PDU_data + PDU_len; p++)
    {
        if ((*p == END) || (*p == ESC))
        {
            SDU_len++;
        }
    }
    // 当前buff不够用时，自动扩展
    if(SDU_len > buffLen)
    {
        free(buff);
        do{
            buffLen = buffLen << 1;
        } while (SDU_len > buffLen);
        buff = (uint8_t*)malloc(buffLen);
    }
    /* send an initial END character to flush out any data that may
     * have accumulated in the receiver due to line noise
     */
    int i = 0;
    buff[i++] = END;

    for (uint8_t *p = p_PDU_data; p < p_PDU_data + PDU_len; p++)
    {
        switch (*p)
        {
        /* if it's the same code as an END character, we send a
         * special two character code so as not to make the
         * receiver think we sent an END
         */
        case END:
            buff[i++] = ESC;
            buff[i++] = (ESC_END);
            break;

        /* if it's the same code as an ESC character,
         * we send a special two character code so as not
         * to make the receiver think we sent an ESC
         */
        case ESC:
            buff[i++] = (ESC);
            buff[i++] = (ESC_ESC);
            break;

        /* otherwise, we just send the character
         */
        default:
            buff[i++] = (*p);
        }
    }

    /* tell the receiver that we're done sending the packet
     */
    buff[i++] = (END);

    return std::make_pair(buff, i);
}

// /**
//  * @brief Serial Line IP UNPACK
//  * @param p_SDU 起始位置指针
//  * @param SDU_len SDU 字节长度
//  * @return std::vector<uint8_t> PDU
//  * @note Service Data Unit (SDU) 指本层解包前的数据单元
//  *       Protocol Data Unit (PDU) 指上层协议数据单元
//  */
// std::vector<uint8_t> SerialLineIP::Unpack(const void *const p_SDU, int SDU_len)
// {
//     std::vector<uint8_t> PDU_data;
//     PDU_data.reserve(SDU_len - 2); //分配足够多的内存空间，减去首位两个END
//     bool begin = false;

//     uint8_t *p_SDU_data = (uint8_t *)p_SDU;
//     for (uint8_t *p = p_SDU_data; p < p_SDU_data + SDU_len; p++)
//     {
//         /* skip until first END character found
//          */
//         if (!begin)
//         {
//             if (*p != END)
//                 continue;
//             else
//                 begin = true;
//         }

//         /* handle bytestuffing if necessary
//          */
//         switch (*p)
//         {
//         /* if it's an END character then we're done with
//          * the packet
//          */
//         case END:
//             /* a minor optimization: if there is no
//              * data in the packet, ignore it. This is
//              * meant to avoid bothering IP with all
//              * the empty packets generated by the
//              * duplicate END characters which are in
//              * turn sent to try to detect line noise.
//              */
//             if (PDU_data.size() > 0)
//                 return PDU_data;
//             else
//                 break;

//         /* if it's the same code as an ESC character, wait
//          * and get another character and then figure out
//          * what to store in the packet based on that.
//          */
//         case ESC:
//             p++;

//             /* if "p" is not one of these two, then we
//              * have a protocol violation.  The best bet
//              * seems to be to leave the byte alone and
//              * just stuff it into the packet
//              */
//             switch (*p)
//             {
//             case ESC_END:
//                 PDU_data.push_back(END);
//                 break;
//             case ESC_ESC:
//                 PDU_data.push_back(ESC);
//                 break;
//             default:
//             /* ESC 后面跟了其他字符 
//              * 这在协议中没有定义，
//              * 则认为这一帧出现差错。
//              */
//                 begin = false;
//                 PDU_data.clear();
//             }
//             break;

//         /* here we fall into the default handler and let
//          * it store the character for us
//          */
//         default:
//             PDU_data.push_back(*p);
//         }
//     }
//     /* 如果没有结束'END'标识符，则返回空
//      */
//     PDU_data.clear();
//     return PDU_data;
// }
#endif /* USE_SRML_SERIAL_LINE_IP || USE_SRML_ASUWAVE_MONITOR */
